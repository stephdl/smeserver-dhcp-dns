{
# write the client A records by reading the DHCP lease file

use HTTP::Date;

	$OUT .= "# DHCP-dependent A Records for $DomainName\n";

	# open the DHCP lease file
	if (open(FILE, '/var/lib/dhcpd/dhcpd.leases')) {

		my ($ip, $hostname, $endtime, $mac, %DefinedHosts);

		# flag the pre-defined host names to avoid a clash
		foreach my $domain (get_domains()) {
			foreach my $h ($hosts->get_hosts_by_domain($domain)) {
				my $hname = $h->key;
				$hname =~ s/\.(.*)$//;
				$DefinedHosts{$hname} = 1;
			}
		}

		# read the entire leases file
		while (<FILE>) {

			# if got an IP we're in a block
			if ($ip) {

				# if end of block, write the output {
				if (/^}/) {
					my ($host, $suff);

					# if there's no hostname, substitute the MAC
					$host = $hostname || $mac;

					# if hostname clashes, re-name to something that either
					# a) doesn't exist, or b) is already defined with the same MAC
					# - condition (b) allows for duplicate leases to the same host
					while (exists $DefinedHosts{$host} &&
							$DefinedHosts{$host} ne $mac) {
						$host = "$hostname-" . ++$suff;
					}
					$DefinedHosts{$host} = $mac;

					# build tinydns data entry with expiry time
					my $exptime = sprintf("4%015x", $endtime);
					$OUT .= "=$host.$DomainName:$ip:0:$exptime\n";
					$ip = '';
				}
				# find hostname, force to lower case
				elsif (/^\s*client-.*"(.*)"/) {
					$hostname = lc $1;

					# sort possibly dodgy Windows names -
					# change spaces to dash, dots to underscore
					$hostname =~ s/\s+/-/g;
					$hostname =~ s/\./_/g;
				}
				# find mac address
				elsif (/^\s*hardware\s+\S+\s+([^;\s]+)/) {
					$mac = $1;
					$mac =~ s/://g;
				}
				# get the lease end date & time
				elsif (/^\s*ends\s+\d\s+([^;]+);/) {
					$endtime = str2time($1);
					#ignore expired leases
					$ip = '' if (time() > $endtime);
				}
			}
			# if we have a lease line, save the IP
			elsif (/^lease\s+(\S+)/) {
				$ip = $1;
			}
		}
		close(FILE);
	}
}
